class Solution {
    int[][] coordinates={{-1,-2},{-1,2},{1,-2},{1,2},{-2,-1},{-2,1},{2,-1},{2,1}};
    
    int helper(int src_x, int src_y, int target_x, int target_y, int n){
        int[][] visited=new int[n][n];
        Queue<int[]> q=new LinkedList<>();
        q.offer(new int[]{src_x, src_y});
        visited[src_x][src_y]=1;
        int steps=0;
        
        while(!q.isEmpty()){
            int qSize=q.size();
            for(int i=0; i<qSize; i++){
                int[] p=q.poll();
                int x=p[0]; int y=p[1];
                if(x==target_x && y==target_y){
                    return steps;
                }
                for(int k=0; k<coordinates.length; k++){
                    int new_x=x+coordinates[k][0];
                    int new_y=y+coordinates[k][1];
                    if(new_x>=0 && new_y>=0 && new_x<n && new_y<n && visited[new_x][new_y]==0){
                        visited[new_x][new_y]=1;
                        q.offer(new int[]{new_x,new_y});
                    }
                }
            }
            steps++;
        }
        return -1;
    }
    public int minStepToReachTarget(int knightPos[], int targetPos[], int n) {
        // Code here
        int src_x=n-knightPos[1];
        int src_y=knightPos[0]-1;
        int target_x=n-targetPos[1];
        int target_y=targetPos[0]-1;
        return helper(src_x,src_y,target_x,target_y,n);
    }
}
